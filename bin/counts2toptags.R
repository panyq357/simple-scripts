#!/usr/bin/env Rscript

parse_arguments <- function() {

    raw_args <- commandArgs(trailingOnly = TRUE)

    help_message = "version: 0.1.0
author: Pan Yongqing

usage: counts2toptags.R [-h] [-f FEATURECOUNTS_FILEPATH] [-t TREATMENT_REGEX] [-c CONTROL_REGEX] [-o OUTPUT_CSV_FILEPATH] [-l FOLD_CHANGE_CUTOFF]

Use edgeR's glmQLFit() and glmTreat() functions to conduct differential expression analysis.
Output results generated by topTags() and cpm() functions.

options:
  -h, --help           show this help message and exit
  -f FEATURECOUNTS_OUTPUT_FILEPATH
                       path to featureCounts output file
  -t TREATMENT_NAME    regex for extract treatment sample from featureCounts output file
  -c CONTROL_NAME      regex for extract control sample from featureCounts output file
  -o OUTPUT_CSV_FILEPATH
                       path to output CSV file
  -l FOLD_CHANGE_CUTOFF
                       fold change cutoff for glmTreat() function (default: 1.5)

dependencies:
  - edgeR
"

    if (length(raw_args) == 0 || raw_args == "-h" || raw_args == "--help") {
        write(help_message, stderr())
        quit()
    }

    args_list <- list()
    option2variable <- c(
        "-f" = "featureCounts_filepath",
        "-t" = "treatment_regex",
        "-c" = "control_regex",
        "-o" = "output_csv_filepath",
        "-l" = "fold_change_cutoff"
    )
    key <- ""
    for (i in 1:length(raw_args)) {
        if (raw_args[i] %in% names(option2variable)) {
            key <- option2variable[raw_args[i]]
            next
        } else {
            if (!is.null(args_list[[key]])) {
                option_name <- names(option2variable[option2variable == key])
                stop(sprintf("Option \"%s\" can only accept one argument!", option_name))
            }
            args_list[[key]] <- raw_args[i]
        }
    }

    if (is.null(args_list[["fold_change_cutoff"]]))
        args_list[["fold_change_cutoff"]] <- 1.5

    for (var in option2variable) {
        if (is.null(args_list[[var]]))
            stop(sprintf("Missing Variable \"%s\"", toupper(var)))
    }

    return(args_list)
}

args_list <- parse_arguments()

library(edgeR)

fc_output <- read.delim(args_list$featureCounts_filepath, comment="#", check.names=F)

colnames_filter_regex <- sprintf(".*(%s|%s).*", args_list$treatment_regex, args_list$control_regex)

counts <- fc_output[grep(colnames_filter_regex, names(fc_output))]
colnames(counts) <- sub(".*/(.+).bam", "\\1", names(counts))
rownames(counts) <- fc_output[["Geneid"]]

group <- make.names(sub(colnames_filter_regex, "\\1", colnames(counts)))

genes <- fc_output["Length"]
rownames(genes) <- fc_output[["Geneid"]]

y <- DGEList(counts=counts, genes=genes, group=group)

keep <- filterByExpr(y)
y <- y[keep, , keep.lib.sizes=FALSE]

y <- calcNormFactors(y)

design <- model.matrix(~0+y$samples$group)
colnames(design) <- levels(y$samples$group)
y <- estimateDisp(y, design, robust=TRUE)
fit <- glmQLFit(y, design, robust=TRUE)

expression_string <- sprintf("%s - %s", make.names(args_list$treatment_regex), make.names(args_list$control_regex))
contrast <- makeContrasts(expression_string, levels = design)

tr <- glmTreat(fit, contrast=contrast, lfc=log2(as.numeric(args_list$fold_change_cutoff)))

output_table <- topTags(tr, n = nrow(y$genes))
log2cpm <- as.data.frame(cpm(y, log=T)[row.names(output_table),])
names(log2cpm) <- paste0("Log2CPM_", names(log2cpm))

output_table <- cbind(data.frame(GeneID=row.names(output_table)), output_table, log2cpm)

write.csv(output_table, args_list$output_csv_filepath, row.names = F)

